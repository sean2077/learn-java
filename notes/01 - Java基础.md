# Java 基础

## 面向对象

### 面向对象三大特征

封装、继承、多态

### 面向对象的五大基本原则

- 单一职责原则(SRP): 一个类，最好只做一件事，只有一个引起它的变化。
- 开放封闭原则(OCP): 软件实体应该是可扩展的，而不可修改的
- 里氏替换原则(LSP): 子类必须能够替换其基类
- 依赖倒置原则(DIP): 依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象
- 接口隔离原则: 使用多个小的专门的接口，而不要使用一个大的总接口

### 访问权限

Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。

可以对类或类中的成员（字段和方法）加上访问修饰符。

- 类可见表示其它类可以用这个类创建实例对象。
- 成员可见表示其它类可以用这个类的实例对象访问到该成员；

protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。

如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。

字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。

可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。

但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。

### 比较下抽象类和接口

- 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
- 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
- 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
- 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。

### 何时使用抽象类，何时使用接口

使用接口：

- 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；
- 需要使用多重继承。

使用抽象类：

- 需要在几个相关的类中共享代码。
- 需要能控制继承来的成员的访问权限，而不是都为 public。
- 需要继承非静态和非常量字段。

在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。

## 数据结构

### [HashMap 容量为什么总是为 2 的次幂？](https://www.cnblogs.com/javastack/p/13356402.html)

HashMap是根据key的hash值决策key放入到哪个桶（bucket）中，通过 tab[(n - 1) & hash] 公式计算得出，其中tab是一个哈希表。

**为什么要通过 (n - 1) & hash 决定桶的索引呢？**

- &运算速度快，至少比%取模运算块

- (n - 1) & hash，当n为2次幂时，会满足一个公式：(n - 1) & hash = hash % n
